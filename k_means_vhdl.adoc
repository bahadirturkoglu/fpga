=                            K_MEANS VHDL KODU +



[source,vhdl]
------------------------------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_SIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;


entity k_means is
generic(
            Data_num:integer:=15;    --datanın eleman sayısı
            Data_bit_num:integer:=8 --elemanların bit sayısı

						);

port  (
 Clk      : in std_logic;
 RST      : in std_logic;
 result   :out std_logic
);
end k_means ;


architecture Behavioral of k_means is


---------------------------------------------------------------------------------------------
--                                      BÖLME İŞLEMİ

function  divide  (a : std_logic_vector; b : std_logic_vector) return std_logic_vector is
variable a1 : std_logic_vector (a'length-1 downto 0):=a;
variable b1 : std_logic_vector(b'length-1 downto 0):=b;
variable p1 : std_logic_vector(b'length downto 0):= (others => '0');
variable i : integer:=0;

begin
for i in 0 to b'length-1 loop
p1(b'length-1 downto 1) := p1(b'length-2 downto 0);
p1(0) := a1(a'length-1);
a1(a'length-1 downto 1) := a1(a'length-2 downto 0);
p1 := p1-b1;
if(p1(b'length-1) ='1') then
a1(0) :='0';
p1 := p1+b1;
else
a1(0) :='1';
end if;
end loop;
return a1;

end divide;


----------------------------------------------------------------------------------------------
signal ctrl_kume: integer:=0;
--------------------------------------------------------
type state is (UZAKLIK,YENI_MERKEZ,KONTROL);
signal state_ctrl : state := UZAKLIK;

type ROM is array (0 to 1) of std_logic_vector(Data_bit_num-1 downto 0);
type ROM_Data is array(0 to Data_num-1) of ROM;
signal data_set : ROM_Data :=(("00000101","00000100"), --DATASET
                              ("00001000","00000111"),
                              ("00000010","00000111"),
                              ("00000001","00000011"),
                              ("00000011","00001001"),
                              ("00000001","00000011"),
                              ("00000101","00001001"),
                              ("00001001","00000110"),
                              ("00000111","00000101"),
                              ("00000110","00001001"),
                              ("00000010","00000011"),
                              ("00000101","00000100"),
                              ("00000111","00001001"),
                              ("00001001","00000100"),
                              ("00000110","00000010"));

signal center_1 :  ROM :=("00000101","00001000"); -- MERKEZ_1
signal center_2 :  ROM :=("00000010","00001000"); -- MERKEZ_2

signal new_center_1,new_center_2 :ROM := (others =>(others =>'0'));--YENİ_MERKEZLER


type cluster is array (0 to Data_num-1) of integer ;
signal cluster_1,cluster_2 : cluster:=(others =>0);

----------------------------------------------------------

begin

process(clk)


variable sub_x1,sub_y1,sub_x2,sub_y2:std_logic_vector(Data_bit_num-1 downto 0):=(others =>'0');
variable mult_x1,mult_y1,mult_x2,mult_y2:std_logic_vector((Data_bit_num*2)-1 downto 0):=(others =>'0');
variable distance_center_1,distance_center_2:std_logic_vector((Data_bit_num*2)-1 downto 0):=(others =>'0');
variable t1 ,t2: std_logic_vector(Data_bit_num-1 downto 0) :=(others => '0');
variable center_1_x,center_1_y,center_2_x,center_2_y: std_logic_vector (Data_bit_num-1 downto 0):=(others =>'0');
variable center_1_point,center_2_point,x,w,data_indis:integer:=0;
variable  out_clk_2 ,out_clk_4,out_clk_8,out_clk_16: std_logic :='0';
variable r_sayac:std_logic_vector(3 downto 0):=(others=> '0');
variable m_ctrl_1,m_ctrl_2, newcenter_ctrl,new_loop_ctrl:std_logic:='0';


begin

out_clk_2  := r_sayac(0);
out_clk_4  := r_sayac(1);
out_clk_8  := r_sayac(2);
out_clk_16 := r_sayac(3);

        if RST='1' then

             data_indis:=0;
             center_1_point:=0;
             center_2_point:=0;

             result<='0';
             newcenter_ctrl:='0';
             new_loop_ctrl:='0';

             cluster_1 <=(others =>0);
             cluster_2 <=(others =>0);

             x:=0;
             w:=0;
             center_1_x:=(others =>'0');
             center_1_y:=(others =>'0');
             center_2_x:=(others =>'0');
             center_2_y:=(others =>'0');

        elsif (clk'event and clk='1') then

        case state_ctrl  is
             when UZAKLIK =>

             r_sayac:=r_sayac+1;

            if(data_indis=Data_num)then         --datanın tüm elemanları için işlem yapıldıysa "YENI_MERKEZ"
                state_ctrl <=YENI_MERKEZ;       --durumuna geç
                new_loop_ctrl:='1';

            end if;

         -- pipeline olarak yapılan uzaklık işlemi
            if(out_clk_2='1')then

                sub_x1:=abs(center_1(0)-data_set(data_indis)(0));
                sub_y1:=abs(center_1(1)-data_set(data_indis)(1));
                sub_x2:=abs(center_2(0)-data_set(data_indis)(0));
                sub_y2:=abs(center_2(1)-data_set(data_indis)(1));
            end if;

            if(out_clk_4='1')then
                mult_x1:=sub_x1*sub_x1;
                mult_y1:=sub_y1*sub_y1;
                mult_x2:=sub_x2*sub_x2;
                mult_y2:=sub_y2*sub_y2;
            end if;

            if(out_clk_8='1')then
                distance_center_1:=mult_x1+mult_y1;
                distance_center_2:=mult_x2+mult_y2;
                ctrl_kume<=1;

            end if;

            if(ctrl_kume=1)then
                if(distance_center_2<=distance_center_1)then --NOKTANIN 2 MERKEZE UZAKLIGININ KARŞILAŞTIRILMASI
                  cluster_2(center_2_point)<=data_indis;
                  data_indis:=data_indis+1;                  -- datanın indisi
                  center_2_point:=center_2_point+1;          -- kume_2'nin indisi


                 else
                  cluster_1(center_1_point)<=data_indis;
                  center_1_point:=center_1_point+1;          -- kume_1'in indisi
                  data_indis:=data_indis+1;                  -- datanın indisi


                end if;
                ctrl_kume<=0;
              end if;

         when YENI_MERKEZ =>

         if(new_loop_ctrl='1')then
            t1:=conv_std_logic_vector(center_1_point,8);
            t2:=conv_std_logic_vector(center_2_point,8);
            center_1_x:=(others =>'0');
            center_1_y:=(others =>'0');
            center_2_x:=(others =>'0');
            center_2_y:=(others =>'0');
            x:=0;
            w:=0;
            newcenter_ctrl:='1';
            new_loop_ctrl:='0';
            end if;
                 if (  newcenter_ctrl='1')then
                     if(x<center_1_point)then
                         center_1_x:=center_1_x+data_set(cluster_1(x))(0); --merkez_1 için kume_1'deki x degerlerinin toplanması
                         center_1_y:=center_1_y+data_set(cluster_1(x))(1); --merkez_1 için kume_1'deki y degerlerinin toplanması
                         x:=x+1;
                     end if;
                     if(x=center_1_point)then
                        new_center_1(0)<= divide ( center_1_x ,t1 );       --yeni merkez_1'İN X DEGERİ
                        new_center_1(1) <= divide ( center_1_y ,t1 );      --yeni merkez_1'İN Y DEGERİ
                        m_ctrl_1:='1';
                     end if;
                     if(w<center_2_point)then
                        center_2_x:=center_2_x+data_set(cluster_2(w))(0);  --merkez_2 için kume_1'deki x degerlerinin toplanması
                        center_2_y:=center_2_y+data_set(cluster_2(w))(1);  --merkez_2 için kume_1'deki y degerlerinin toplanması
                        w:=w+1;
                     end if;
                     if(w=center_2_point)then
                        new_center_2(0)<= divide ( center_2_x ,t2 );     --yeni merkez_2'İN X DEGERİ
                        new_center_2(1) <= divide (center_2_y ,t2 );     --yeni merkez_2'İN Y DEGERİ
                        m_ctrl_2:='1';
                     end if;
                     if(m_ctrl_1='1' and m_ctrl_2='1')then
                       state_ctrl  <=KONTROL;
                       m_ctrl_1:='0';
                       m_ctrl_2:='0';
                     end if;
                 end if;

           when KONTROL=>

           if(center_1=new_center_1 and center_2=new_center_2 )then  --eski ve yeni merkezlerıin karşılaştırılması

           result<='1';

           else
           center_1<=new_center_1;
           center_2<=new_center_2;
           state_ctrl  <=UZAKLIK;        --yeni merkez eski merkeze eşit değilse "UZAKLIK" durumuna dön
           data_indis:=0;
           center_1_point:=0;
           center_2_point:=0;

           newcenter_ctrl:='0';
           cluster_1 <=(others =>0);
           cluster_2 <=(others =>0);
           end if;

         when others => NULL;
   end case;

end if;
end process;

end Behavioral;



------------------------------------------------------------------------------------------------------------------

SİMULASYON +

image::https://github.com/bahadirturkoglu/fpga/raw/master/k_means.PNG[R]




